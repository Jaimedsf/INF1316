NAGIB MOURA SUAID - 1710839
PEDRO CHAMBERLAIN MATOS - 1710883

QUESTÃO 1) 

Explique o funcionamento do programa filhocídio.c

-----------------------------------------------------------------------------------------

FILHOCIDIO.C

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>
#define EVER ;;

void childhandler(int signo);
int delay;

int main (int argc, char *argv[]) {
	pid_t pid;
	
	signal(SIGCHLD, childhandler);
	
	if ((pid = fork()) < 0) {
		fprintf(stderr, "Erro ao criar filho\n");
		exit(-1);
	}
	
	if (pid == 0) /* child */
		for(EVER); /* ou sleep(3);*/
	else /* parent */ {
		sscanf(argv[1], "%d", &delay); /* read delay from command line */
		sleep(delay);
		printf("Program %s exceeded limit of %d seconds!\n", argv[2], delay);
		kill(pid, SIGKILL);
	}
	return 0;
}

void childhandler(int signo) /* Executed if child dies before parent */ {
	int status;
	pid_t pid = wait(&status);
	printf("Child %d terminated within %d seconds com estado %d.\n", pid, delay, status);
	exit(0);
}

-----------------------------------------------------------------------------------------

COMPILAÇÃO E EXECUÇÃO

gcc -o filhocidio filhocidio.c
filhocidio.c: In function ‘childhandler’:
filhocidio.c:33:14: warning: implicit declaration of function ‘wait’; did you mean ‘main’? [-Wimplicit-function-declaration]
pid_t pid = wait(&status);
            ^~~~
            main

-----------------------------------------------------------------------------------------

RESULTADO

./filhocidio 5
Program (null) exceeded limit of 5 seconds!

-----------------------------------------------------------------------------------------

CONCLUSÃO

O processo pai aguarda por um limite de tempo para o processo filho encerrar sua execução.

Caso o processo filho seja concluído dentro desse tempo limite, o sinal SIGCHLD é
enviado, ativando a função childhandler, que confirma que o processo filho foi encerrado
dentro do tempo determinado, terminando o programa.

Caso o processo filho não seja concluído a tempo, o processo pai envia uma mensagem
explicando que o filho excedeu o tempo limite, enviando o sinal SIGKILL, encerrando o
programa.

-----------------------------------------------------------------------------------------


QUESTÃO 2)

Altere o programa filhocidio.c para que o filho, em vez de executar o for(EVER), dê um
exec() no programa sleep5 e depois no programa sleep15 indicados a seguir.
Execute cada um e explique o funcionamento desta nova versão do programa filhocidio.c

-----------------------------------------------------------------------------------------

FILHOCIDIO2.C

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

void childhandler(int signo);
int delay;
char string[30];

int main (int argc, char *argv[]) {
	pid_t pid;
	
	signal(SIGCHLD, childhandler);
	
	if ((pid = fork()) < 0) {
		fprintf(stderr, "Erro ao criar filho\n");
		exit(-1);
	}
	
	if (pid == 0) /* child */ {
		sscanf(argv[2], "%s", string);
		execv(string, argv);
	}		

	else /* parent */ {
		sscanf(argv[1], "%d", &delay); /* read delay from command line */
		sleep(delay);
		printf("Program %s exceeded limit of %d seconds!\n", argv[2], delay);
		kill(pid, SIGKILL);
	}
	return 0;
}

void childhandler(int signo) /* Executed if child dies before parent */ {
	int status;
	pid_t pid = wait(&status);
	printf("Child %d terminated within %d seconds com estado %d.\n", pid, delay, status);
	exit(0);
}


-----------------------------------------------------------------------------------------

COMPILAÇÃO E EXECUÇÃO

gcc -o filhocidio2 filhocidio.c
filhocidio.c: In function ‘childhandler’:
filhocidio.c:37:14: warning: implicit declaration of function ‘wait’; did you mean ‘main’? [-Wimplicit-function-declaration]
pid_t pid = wait(&status);
            ^~~~
            main

gcc -o sleep15 sleep15.c



-----------------------------------------------------------------------------------------

RESULTADO

./filhocidio2 5 ./sleep15
indo dormir...
Program ./sleep15 exceeded limit of 5 seconds!

./filhocidio2 20 ./sleep15
indo dormir...
Acordei!
Child 4476 terminated within 20 seconds com estado 0.


-----------------------------------------------------------------------------------------

QUESTÃO 3)

Tente fazer um programa para interceptar o sinal SIGKILL. 
Você conseguiu? Explique.

-----------------------------------------------------------------------------------------

UNKILLABLE.C

#include <stdio.h>
#include <signal.h>
#include <unistd.h>
#include <stdlib.h>

#define EVER ;;

void trataKill(int signo);
	int main(){
	int i=0;
	signal(SIGKILL,trataKill);
	for(EVER){i++;}
	return 0;
}

void trataKill(int signo){
	printf("sinal ignorado\n");
}


-----------------------------------------------------------------------------------------

COMPILAÇÃO E EXECUÇÃO

gcc -o ukillable unkillable.c

-----------------------------------------------------------------------------------------

RESULTADO

$ ./unkillable &
[1] 4222
$ ps
PID TTY TIME CMD
2151 pts/0 00:00:00 csh
4222 pts/0 00:00:03 unkillable
4224 pts/0 00:00:00 ps
$ kill -s KILL 4222
$ ps
PID TTY TIME CMD
2151 pts/0 00:00:00 csh
4230 pts/0 00:00:00 ps
[1] + Killed ./unkillable

-----------------------------------------------------------------------------------------

CONCLUSÃO

O tratamento do sinal SIGKILL não pode ser sobrescrito, logo o handler criado
não é executado.

-----------------------------------------------------------------------------------------

QUESTÃO 4)

Faça um programa que leia 2 números reais e imprima o resultado das 4 operações
básicas sobre estes 2 números.
- Verifique o que acontece se o segundo número da entrada for 0 (zero)
- Capture o sinal de erro de floating point (SIGFPE) e repita a experiência anterior

-----------------------------------------------------------------------------------------

OPERACOES.C

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>

void numhandler(int signo);

int main (int argc, char *argv[]) {
	int nums[2], soma, subt, prod, divs;
	sscanf(argv[1], "%d", &nums[0]);
	sscanf(argv[2], "%d", &nums[1]);
	
	signal(SIGFPE, numhandler);
	
	soma = nums[0] + nums[1];
	subt = nums[0] - nums[1];
    prod = nums[0] * nums[1]; 
	divs = nums[0] / nums[1];
          
	printf("X = %d; Y = %d\n%d\n%d\n%d\n%d\n", nums[0], nums[1], soma, subt, prod, divs);
	
	return 0;
}

void numhandler(int signo) {
	printf("divisão por zero!\n");
	exit(0);
}

-----------------------------------------------------------------------------------------

COMPILAÇÃO E EXECUÇÃO

gcc -o operacoes operacoes.c

-----------------------------------------------------------------------------------------

RESULTADO

[SEM SIGFPE]
./operacoes 1 0
Floating point exception (core dumped)

[COM SIGFPE]
./operacoes 1 0
divisão por zero!


-----------------------------------------------------------------------------------------

QUESTÃO 5)

Faça um programa para monitorar e informar o preço de chamadas telefônicas. O programa
deverá ser executado em background.
- O início e o término de uma chamada são informados através dos sinais USR1 e USR2,
respectivamente.
- O custo da ligação é de 2 centavos por segundo, para ligações de até 1 minuto ou de 1
centavo por segundo a partir do 2o. minuto, ou seja, uma ligação de 1m30s custa R$1,50.

-----------------------------------------------------------------------------------------

TELEFONE.C

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <signal.h>
#define EVER ; ;

void call(int signo);
void endcall(int signo);
clock_t tempo;

int main (void) {
	signal(SIGUSR1, call);
	signal(SIGUSR2, endcall);
	
	for(EVER);
	
	return 0;
}

void call(int signo) {
	printf("LIGANDO...\n");
	tempo = clock();
}

void endcall(int signo) {
	int secs;
	float preco;
	
	printf("DESLIGANDO...\n");
	
	tempo = clock() - tempo;
	secs = (int) tempo / CLOCKS_PER_SEC;
	
	if (secs <= 60)
		preco = (secs * 2) / 100.0; 
	else
		preco = 1.20 + (secs / 100.0);
		
	printf("TEMPO DA CHAMADA: %d segundos - PREÇO: %.02f\n", secs, preco);
	exit(1);
}

-----------------------------------------------------------------------------------------

COMPILAÇÃO E EXECUÇÃO

gcc -o telefone telefone.c

-----------------------------------------------------------------------------------------

RESULTADO

$ ./telefone &
[1] 6619
$ kill -s USR1 6619
LIGANDO...
$ kill -s USR2 6619
DESLIGANDO...
TEMPO DA CHAMADA: 8 segundos - PREÇO: 0.16
[1]+  Exit 1                  ./telefone


