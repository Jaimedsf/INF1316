NAGIB MOURA SUAID - 1710839
PEDRO CHAMBERLAIN MATOS - 1710883

Trabalho 1 de Sistemas Operacionais: Escalonamento em Múltiplos Níveis com Feedback

================================== CÓDIGO FONTE ==================================

ESCALONADOR.C:

#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>
#include <signal.h>
#include <string.h>
#include <time.h>

#define MAX_PROCS 50
#define MAX_STR 200

typedef struct Processo {

   pid_t pid;           /*pid do processo*/
   int prioridade;      /*a fila para a qual o processo deve voltar apos E/S*/
   time_t timestamp;	  /*tempo que o processo perdura em dado momento*/

} processo;

typedef struct Fila {

   int membros;                /*numero de processos na fila*/
   int proximo;                /*indice do proximo processo nessa fila*/
   processo* vet[MAX_PROCS]; /*referencias para processos*/

} fila;

fila* criaFila();
/*retorna referencia para uma fila vazia*/

int getMembros(fila* f);
/*retorna o numero de processos na fila f*/

int insProc(processo* p, fila* f);
/*insere o processo p no final da fila f, retornando o numero de processos
na fila apos a insercao*/

processo* getNext(fila* f, int remove);
/*retorna uma referencia para o proximo da fila, o remove se remove for diferente de 0*/

void handler1(int s);
/*tratador de SIGUSR1, suposto w4IO de um processo filho*/

void handler2(int s);
/*tratador de SIGCHLD, recebido quando processo filho termina*/

void handler3(int s);
/*tradador de SIGALRM, representante de quando o quantum do processo esgota*/

void manageFila(int quantum);
/*tratador das filas de processo*/

void checkIO(void);
/*verifica se algum processo em espera pode voltar a sua fila*/


fila * terminados;
fila * prioridade1;
fila * prioridade2;
fila * prioridade3;
fila * esperando;
processo *proc;
int nProcs;
int quantum;
fila* corrente;
fila* inferior;
int nSuperior;
int nInferior;


int main (int argc, char* argv[]) {
  
   int ret;

   pid_t pid;
   char nome[MAX_STR];
   char args[MAX_STR];
   char pb[MAX_STR+2] = "./";
   char *parms[3];
   processo* proc;
   
   FILE * arq;
   
   terminados=criaFila();
   prioridade1=criaFila();
   prioridade2=criaFila();
   prioridade3=criaFila();
   esperando=criaFila();
   
   signal(SIGUSR1,handler1);
   signal(SIGUSR2,handler2);
   signal(SIGALRM,handler3);
   parms[2] = (char*)0;
   if(argc != 2){
     
     printf("Argumentos errados!\n");
     exit(1);
   }
  
   arq = fopen(argv[1],"r");
   if (arq == NULL){
     
     printf("Erro ao abrir arquivo : %s\n",argv[1]);
     exit(1);
   }
   
   ret = fscanf(arq, "exec %s %s\n", nome, args);
   nProcs = 0;
   while (ret >= 0) {
   
      proc = (processo *) malloc(sizeof(processo));
      parms[0]=nome;
      parms[1]=args;
      strcat(pb,nome);
      pid=fork();
      
      if(pid == 0){
         execv(pb,parms);
         perror("execv");
         return 0;
      }
      proc->prioridade = 1;
      proc->pid = pid;
      insProc(proc,prioridade1);
      nProcs++;
	  
      ret = fscanf(arq, "exec %s %s\n", nome, args);
      pb[2]='\0';
   
   }
   
   sleep(3);
   int i=0;
   while(nProcs>0) {
     
      i=getMembros(prioridade1);
      if(i>0){
         manageFila(1);
      }
      else{
         i=getMembros(prioridade2);
         if(i>0){
            manageFila(2);
         }
         else{
            manageFila(3);
         }
      }
 
   }
   
   free(prioridade1);
   free(prioridade2);
   free(prioridade3);
   free(esperando);
   proc=getNext(terminados, 1);
   
   while(proc != NULL){
     free(proc);
     proc=getNext(terminados, 1);
   }
      
      
   free(terminados);
   return 0;
}
              
void manageFila(int prioridade) {
   int ret;
   
   pid_t pid;
  
   switch (prioridade) {
     case 1:
       quantum = 2;
       corrente = prioridade1;
       inferior = prioridade2;
       nSuperior = 1;
       nInferior = 2;
       break;
       
     case 2:
       quantum = 4;
       corrente = prioridade2;
       inferior = prioridade3;
       nSuperior = 1;
       nInferior = 3;
       break;
       
     case 3:
       quantum = 8;
       corrente = prioridade3;
       inferior = prioridade3;
       nSuperior = 2;
       nInferior = 3;
       break;
   }
  
   ret=getMembros(corrente);
    for(int i=0;i<ret;i++){
       proc = getNext(corrente, 1);
       pid=proc->pid;

       alarm(quantum);
       printf("\n> Executando %d na fila %d\n",pid,prioridade);
       kill(pid,SIGCONT);
       pause();

      checkIO();
  }  

  checkIO();
}


fila* criaFila(){
   fila* f;
   f=(fila*)malloc(sizeof(fila));
   f->membros=0;
   return f;
}

int getMembros(fila* f){
   return f->membros;
}

int insProc(processo* p, fila* f){

   if(f->membros == 0){
      
      f->membros = 1;
      f->proximo = 0;
      f->vet[0] = p;
   
   }
   else{
      f->vet[(f->proximo + f->membros)%MAX_PROCS]=p;
      f->membros = f->membros + 1;
   }
   return f->membros;
}

processo* getNext(fila* f, int remove){
   
   processo* ret;
   if(remove == 0){
      return f->vet[f->proximo];
   }
   if(f->membros == 0)
      return NULL;

   ret = f->vet[f->proximo];
   f->vet[f->proximo] = NULL;
   f->proximo=((f->proximo)+1)%MAX_PROCS;
   f->membros = f->membros - 1;
   return ret;
}

void handler1(int s){

   alarm(0);
   printf("\n> %d pediu I/O\n",proc->pid);
   
   proc->prioridade = nSuperior;
   insProc(proc,esperando);
   time(&(proc->timestamp));
}

void handler2(int s){
   kill(proc->pid,SIGKILL);
   alarm(0);
   printf("\n> %d terminou\n",proc->pid);
  
   insProc(proc,terminados);
   nProcs--;
}

void handler3(int s){
  kill(proc->pid,SIGSTOP);
  printf("\n> %d esgotou seu quantum\n",proc->pid);
  proc->prioridade = nInferior;
  insProc(proc,inferior);
  
}

void checkIO(void){
   time_t segundos;
   if(getMembros(esperando)>0){
        proc = getNext(esperando, 0);
        time(&segundos);

        while( (difftime(segundos,proc->timestamp))>= 3){
           switch(proc->prioridade){
             case 1:
               insProc(proc,prioridade1);
               break;
             case 2:
               insProc(proc,prioridade2);
               break;
             case 3:
               insProc(proc,prioridade3);
               break;
           }
           getNext(esperando, 1);
           proc = getNext(esperando, 0);
           if (proc == NULL)
               break;
      }
   }
}

   


##################################################################################

USER_PROGRAM.C

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <sys/types.h>
#include <unistd.h>

int main (int argc, char * argv[]) {

   int n_rajadas = 0;
   int i, j;
   pid_t pid_pai;
   char * string;
   int rajadas[50];
   
   if(argc != 2) {
      printf("Uso errado do programa!");
      fflush(stdout);
      exit(1);
   }

   pid_pai = getppid();
   
   string = &(argv[1][1]);
   i = 1;

   while(string[0] != '\0') {
      while(argv[1][i] != ',' && argv[1][i] != ')')
         i++;
         
      argv[1][i]='\0';
      
      rajadas[n_rajadas] = atoi(string);  
      n_rajadas++;
      string = &(argv[1][i+1]);
   }
   raise(SIGSTOP);
   for(i = 0; i < n_rajadas; i++) {
      for(j = 0; j < rajadas[i]; j++) { 
         printf("pid: %d| i: %d| j:%d\n", getpid(),i,j);
         sleep(1);
      }
      if(i != n_rajadas - 1){
         kill(pid_pai, SIGUSR1);
         raise(SIGSTOP);
      }
   }
   kill(pid_pai, SIGUSR2);
   return 0;

}

----------------------------------------------------------------------------------

============================== TESTE DO ESCALONADOR ==============================

Para testarmos o escalonador elaborado para o trabalho, utilizaremos os seguintes
processos:
	
	P1: 4 -> I/O -> 1 -> I/O -> 4
	P2: 1 -> I/O -> 4 -> I/O -> 1
	P3: 16

Esses estão inseridos num arquivo de texto processo.txt que será enviado ao
programa escalonador.c como um parâmetro.

PROCESSO.TXT

exec user_program (4,1,4)
exec user_program (1,4,1)
exec user_program (16)

----------------------------------------------------------------------------------

============================== EXECUÇÃO DO PROGRAMA ==============================

$ ./escalonador processo.txt

> Executando 4266 na fila 1
pid: 4266| i: 0| j:0
pid: 4266| i: 0| j:1

> 4266 esgotou seu quantum

> Executando 4267 na fila 1
pid: 4267| i: 0| j:0

> 4267 pediu I/O

> Executando 4268 na fila 1
pid: 4268| i: 0| j:0
pid: 4268| i: 0| j:1

> 4268 esgotou seu quantum

> Executando 4266 na fila 2
pid: 4266| i: 0| j:2
pid: 4266| i: 0| j:3

> 4266 pediu I/O

> Executando 4268 na fila 2
pid: 4268| i: 0| j:2
pid: 4268| i: 0| j:3
pid: 4268| i: 0| j:4
pid: 4268| i: 0| j:5

> 4268 esgotou seu quantum

> Executando 4267 na fila 1
pid: 4267| i: 1| j:0
pid: 4267| i: 1| j:1

> 4267 esgotou seu quantum

> Executando 4266 na fila 1
pid: 4266| i: 1| j:0

> 4266 pediu I/O

> Executando 4267 na fila 2
pid: 4267| i: 1| j:2
pid: 4267| i: 1| j:3

> 4267 pediu I/O

> Executando 4268 na fila 3
pid: 4268| i: 0| j:6
pid: 4268| i: 0| j:7
pid: 4268| i: 0| j:8
pid: 4268| i: 0| j:9
pid: 4268| i: 0| j:10
pid: 4268| i: 0| j:11
pid: 4268| i: 0| j:12
pid: 4268| i: 0| j:13

> 4268 esgotou seu quantum

> Executando 4266 na fila 1
pid: 4266| i: 2| j:0
pid: 4266| i: 2| j:1

> 4266 esgotou seu quantum

> Executando 4267 na fila 1
pid: 4267| i: 2| j:0

> 4267 terminou

> Executando 4266 na fila 2
pid: 4266| i: 2| j:2
pid: 4266| i: 2| j:3

> 4266 terminou

> Executando 4268 na fila 3
pid: 4268| i: 0| j:14
pid: 4268| i: 0| j:15

> 4268 terminou


----------------------------------------------------------------------------------

=================================== EXPLICAÇÃO ===================================

Na impressão do programa, os processos são identificados pelo pid, o termo i 
representa a atual rajada na qual o mesmo se encontra, e j mostra quantos segundos 
já foram  percorridos nesta rajada. As filas 1, 2 e 3 apresentam, respectivamente,
os quantums: 2, 4 e 8.

Inicialmente, os três programas se encontram na primeira fila, sendo o processo 1
(P1), o primeiro a ser executado. Ela percorre 2 segundos do seu processo até ele
ser interrompido. Como ele não cumpriu sua rajada em tempo, ele é transferido para
a segunda fila. 
P1: (2/4, 0/1, 0/4)

Após a transferência, o processo 2 (P2) é iniciado, percorrendo um segundo. Como
o mesmo, após um segundo, já conclui sua rajada, ele envia um sinal para aguardar
a entrada e saída. Como seu tempo não utrapassa o quantum, ele entra na fila de
espera sem perder a prioridade. 
P2: (1/1, 0/4, 0/1)

Após P2, o processo 3 (P3) é iniciado. P3 executa por 2 segundos, ultrapassa o
quantum e é transferido para a segunda fila. 
P3: (2/16)

Apesar de P2 ter maior prioridade, o mesmo se encontra na fila de espera. Tendo
isso, como a única fila onde existem processos é a segunda, os processos P1 e P3
são rodados.

O processo P1 roda por 2 segundos e aguarda a entrada e saída. Como ele concluiu
sua rajada, ele é encaminhado para a fila de espera, futuramente sendo inserido 
na primeira fila de processos quando o mesmo for acordado para a próxima rajada.
P1: (4/4, 0/1, 0/4)

O processo P3 roda por 4 segundos, mas como o mesmo ultrapassa o quantum, ele
entra na terceira fila de prioridade. 
P3: (6/16)

Enquanto P3 se encontra na terceira fila de prioridade, P1 e P2 aguardam suas
respectivas rajadas na primeira fila. Visto que os dois últimos tem prioridade,
esses são rodados.

Como P2 terminou o I/O antes, ele é iniciado antes de P1. P2 executa por 2 
segundos, ultrapassa o quantum e agora é transferido para a segunda fila.
P2: (1/1, 2/4, 0/1)
    
Após P2, P1 é iniciado, percorrendo um segundo. Com a rajada concluída, envia 
um sinal e aguarda a entrada e saída, entrando posteriormente na fila de
espera sem perder a prioridade.
P1: (4/4, 1/1, 0/4)

Como P1 se encontra na fila de espera, P2 está na segundo fila e P3 está na 
terceira fila de espera, P2 é rodado antes de P3.

P2 roda por 2 segundos e conclui sua rajada, aguardando a entrada e saída e 
sendo subida para a primeira fila. 
P2: (1/1, 4/4, 0/1)

Após isso, P3 é rodado 8 segundos, ultrapassando mais uma vez o quantum,
mantendo-se na terceira fila de prioridade.
P3: (14/16)

Após P3, P1 inicia na primeira fila de prioridade, rodando por dois segundos,
ultrapassando seu quantum e sendo transferido para a segunda fila.
P1: (4/4, 1/1, 2/4)

P2 roda após P1, percorrendo por apenas mais um segundo, sendo terminado.
P2: (1/1, 4/4, 1/1) - CONCLUÍDO

Como P1 se encontra na segunda fila e P3 na terceira, P1 é rodado antes.
Após percorridos 2 segundos, P1 é concluído.
P1: (4/4, 1/1, 4/4) - CONCLUÍDO

Por final, P3 percorre por 2 segundos na terceira fila de prioridade, sendo
concluído com sucesso e encerrando a fila de processos.
P3: (16/16) - CONCLUÍDO

O escalonador funcionou da maneira prevista.

